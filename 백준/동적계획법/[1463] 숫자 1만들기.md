## BFS 풀이

```python

from collections import deque

num = int(input())

def bfs(num):
    #연산의 최대값 = 1로 계속 빼서 1을 만드는 경우 - 1
    min_num = num 
    stack = deque()
    stack.append([num, 0])
    while len(stack) > 0:
        elem = stack.popleft()
        value = elem[0]
        depth = elem[1]
        if value == 1:
            if min_num > depth:
                min_num = depth
        elif depth <= num - 1:
            if value - 1 >= 0:
                stack.append([value - 1, depth + 1] )
            if value % 3 == 0:
                stack.append([value // 3, depth + 1])
            if value % 2 == 0:
                stack.append([value // 2, depth + 1])
    
    return min_num

result = bfs(num)
print(result)
```
