### 풀이 과정
우선 각 문자열마다 일치하는 문자를 찾기 위해 완전 탐색을 진행해야 하다. 
이때, 중복되는 값이 있는지 확인할 수 있다면 점화식을 도출하여 동적 계획법으로 풀이 가능하다.  

우선 일치하는 문자를 찾기 위해서는 for 루프를 적어도 2번은 돌아야 한다. 

그후 만약 일치하는 문자를 찾았다면? / 찾지 못했다면? 2가지 조건으로 나눌 수 있다. 

#### i) 일치하는 문자를 찾았을 경우  
이전에 찾은 최댓값에서 1을 더해준다. 

#### ii) 일치하는 문자를 찾지 못했을 경우  
이전에 찾은 문자열 중 max([Xi - 1, Yj], [X, Yj -1]) 를 해준다. 
예시로 'ab'와 'ac'가 있다고 하자. 
a와 ac를 먼저 비교하는데, 처음부터 일치하는 문자열을 찾았기 때문에 최대 길이는 현재 1이다. 
하지만, a와 ac에서부터는 문자가 다르다. 그럼 ([a, a]의 문자열,["", "ac"]의 문자열) 중 최대 값을 설정해준다. 

| ACAYKP | CAPCAK  | [xi에서 최대 값, yj에서 최대값]   |
|--------|---------|-----------------------------------|
| ""     | "[C-K]" | [0, len(b)] = 0                   |
| "A"    | "C"     | [1, 1] = 0                        |
|        | A       | [1, 2] = [0, 1] + 1 = 1           |
|        | P       | [1, 3] = max([0, 3], [1, 2]) = 1  |
|        | C       | [1, 4] = max([0, 4] , [1, 3]) = 1 |
|        | A       | [1, 5] = [0, 4] + 1 = 1           |
|        | K       | [1, 6] = max([0, 6], [1, 5]) = 1  |


### 코드
```
import sys
s1 = sys.stdin.readline().rstrip()
s2 = sys.stdin.readline().rstrip()

s1_len = len(s1)
s2_len = len(s2)

L = [[0] * (s2_len + 1) for _ in range (s1_len + 1)]

for i in range(s1_len+1):
    for j in range(s2_len+1):
        #비교 문자가 없는 초기 상태
        if i == 0 or j == 0:
            L[i][j] = 0
        elif s1[i - 1] == s2[j - 1]:
            L[i][j] = L[i-1][j-1] + 1
        else:
            L[i][j] = max(L[i-1][j], L[i][j-1])

print(L[s1_len][s2_len])
```
